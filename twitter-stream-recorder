#!/usr/bin/perl

############################################################################
##  Twitter stream recorder
##
##  This program is free software; you can redistribute it and/or modify
##  it under the terms of the GNU General Public License as published by
##  the Free Software Foundation; either version 2 of the License, or
##  (at your option) any later version. See: COPYING-GPL.txt
##
##  This program  is distributed in the  hope that it will  be useful, but
##  WITHOUT   ANY  WARRANTY;   without  even   the  implied   warranty  of
##  MERCHANTABILITY  or FITNESS  FOR A  PARTICULAR PURPOSE.   See  the GNU
##  General Public License for more details.
##
##  You should have received a copy of the GNU General Public License
##  along with this program. If not, see <http:##www.gnu.org/licenses/>.
##
##  2015 - Jonathan G Rennison <j.g.rennison@gmail.com>
############################################################################

use strict;
use warnings;
use utf8;

use JSON;
use AnyEvent;
use AnyEvent::Twitter 0.63;
use AnyEvent::Twitter::Stream;
use Getopt::Std;
use File::Slurp;
use File::HomeDir;
use String::Numeric;

my $consumer_key    = q(rzAkUMSeOG9dtp85cywZZDisb);
# This is totally a secret...
my $consumer_secret = q(fMxkxJ5HrBY1f4XQE1Oux0VAOMPDhRmLFBzVndhedjRohiUbRa) =~ tr/n-za-mN-ZA-M/a-zA-Z/r;
my $access_token;
my $access_token_secret;
my $user_json;
my $highest_id = 0;
my $file = File::Spec->catfile(File::HomeDir->my_home, '.twitter-stream-recorder');
my $preload_tweets = 0;

sub usage {
	print STDERR <<"EOL";
twitter-stream-recorder [options]
Prints a twitter streaing API userstream to STDOUT.

Options:
-f CONFIG_FILE
	Use CONFIG_FILE for API authorisation details.
	Will not overwrite an existing file.
	If the file does not exist, the user must
	interactively authorise the application (enter a PIN on STDIN).
	Defaults to $file
-n
	Non-interactive mode.
	Fail if interactive authorisation is required.
-p INTEGER
	Prepend this many tweets to the output (using the REST API).
	Defaults to $preload_tweets
-h
	Show usage
EOL
	exit 1;
}

my %opts;
getopts(':f:np:h', \%opts) or usage();
usage() if defined $opts{'h'};
$file = $opts{'f'} if defined $opts{'f'};
my $non_interactive = defined $opts{'n'};
$preload_tweets = $opts{'p'} if defined $opts{'p'};

unless(String::Numeric::is_int($preload_tweets) && $preload_tweets >= 0 && $preload_tweets <= 800) {
	die("-p (tweets to pre-load) mut be an integer in the range 0-800");
}

my $rest_cv;
my @rest_cv_pending; # stream tweets are pushed to end, REST tweets are unshifted to front

sub setup_rest_cv {
	return if $rest_cv && !$rest_cv->ready;

	$rest_cv = AnyEvent->condvar;
	$rest_cv->cb(sub {
		print_json($_) for @rest_cv_pending;
		@rest_cv_pending = ();
	});
}

sub authorise {
	# This is mostly based on AnyEvent::Twitter example code

	my %request_token;
	my $cv = AE::cv;
	$cv->begin;
	AnyEvent::Twitter->get_request_token(
		consumer_key    => $consumer_key,
		consumer_secret => $consumer_secret,
		callback_url    => 'oob',
		cb => sub {
			my ($location, $response, $body, $header) = @_;
			%request_token = %$response;

			print "\n",
				  "Access the authorization URL and get the PIN at \n\n",
				  "$location\n\n";

			$cv->end;
		},
	);
	$cv->recv;

	print "Input the PIN:\n";
	my $pin = <STDIN>;
	chomp $pin;

	$cv = AE::cv;
	$cv->begin;
	AnyEvent::Twitter->get_access_token(
		consumer_key       => $consumer_key,
		consumer_secret    => $consumer_secret,
		oauth_token        => $request_token{oauth_token},
		oauth_token_secret => $request_token{oauth_token_secret},
		oauth_verifier     => $pin,
		cb => sub {
			my ($token, $body, $header) = @_;
			$access_token         = $token->{oauth_token};
			$access_token_secret  = $token->{oauth_token_secret};
			$cv->end;
		},
	);
	$cv->recv;

	my $ua = get_ae_twitter();
	my ($vc_cv) = verify_cred($ua);
	$vc_cv->recv;

	print "\n",
	      "access_token        is $access_token\n",
	      "access_token_secret is $access_token_secret\n",
	      "user ID is " . $user_json->{id} . "\n",
	      "user screen_name is @" . $user_json->{screen_name} . "\n\n";

	my %new = (
		consumer_key    => $consumer_key,
		consumer_secret => $consumer_secret,
		token           => $access_token,
		token_secret    => $access_token_secret,
		user_id         => $user_json->{id},
	);
	write_file($file, { no_clobber => 1, err_mode => 'carp' }, encode_json(\%new));
}

sub load_config {
	my $config = decode_json(read_file($file));
	$consumer_key = $config->{consumer_key};
	$consumer_secret = $config->{consumer_secret};
	$access_token = $config->{token};
	$access_token_secret = $config->{token_secret};
}

sub get_ae_twitter {
	my $ua = AnyEvent::Twitter->new(
		consumer_key    => $consumer_key,
		consumer_secret => $consumer_secret,
		token           => $access_token,
		token_secret    => $access_token_secret,
	);
	return $ua;
}

sub verify_cred {
	my ($ua, $use_cv) = @_; # use_cv is optional
	my $cv = $use_cv // AE::cv;

	$cv->begin;
	$ua->get('account/verify_credentials', sub {
		my ($header, $response, $reason) = @_;
		$user_json = $response;
		$cv->end;
	});
	return ($cv);
}

sub stream {
	my ($ua, $use_cv, $onconnect) = @_; # use_cv is optional
	my $cv = $use_cv // AE::cv;

	$cv->begin;
	my $listener = AnyEvent::Twitter::Stream->new(
		consumer_key    => $consumer_key,
		consumer_secret => $consumer_secret,
		token           => $access_token,
		token_secret    => $access_token_secret,
		method          => "userstream",
		timeout         => 180,
		on_eof          => sub {
			$cv->end;
		},
		on_error        => sub {
			my ($error) = @_;
			warn "Streaming error: $error";
			$cv->end;
		},
		on_tweet        => sub {
			my ($tweet) = @_;
			stream_print_json($tweet);
			handle_tweet($tweet);
		},
		on_friends      => sub {
			$onconnect->() if $onconnect;
		},
	);

	return ($cv, $listener);
}

sub handle_tweet {
	my ($tweet) = @_;
	eval {
		my $id = $tweet->{id};
		if(defined $id && $id > $highest_id) {
			$highest_id = $id;
		}
	};
	warn $@ if $@;
}

sub stream_print_json {
	if($rest_cv->ready) {
		print_json(shift);
	}
	else {
		push @rest_cv_pending, shift;
	}
}

sub rest_print_json {
	unshift @rest_cv_pending, shift;
}

sub print_json {
	my ($obj) = @_;
	print encode_json($obj) . "\n";
}

sub rest_fetch {
	my ($ua, $cv, $count, $max_id, $since_id) = @_;

	my $more_pending = 1;
	my %params = (
		include_entities  => 1
	);
	$params{since_id} = $since_id if defined $since_id;
	$params{max_id} = $max_id if defined $max_id;
	if($count > 200) {
		$params{count} = 200;
	}
	else {
		$params{count} = $count;
	}

	# Most recent (highest ID) comes first
	# Least recent (lowest ID) comes last
	# First page will be the newest

	$cv->begin;
	$ua->get('statuses/home_timeline', \%params, sub {
		my ($header, $response, $reason) = @_;
		if(ref($response) eq "ARRAY") {
			my $tweet_count = scalar @$response;
			if($tweet_count) {
				my $lowest_id = $response->[-1]->{id};
				for my $tweet (@$response) {
					rest_print_json($tweet);
					handle_tweet($tweet);
				}

				if($count > 200 && $tweet_count > 150) {
					# Possibly more tweets in next page
					# Use 150 as threshold to deal with a few tweets being filtered out due to deletion, etc.
					rest_fetch($ua, $cv, $count - 200, $lowest_id - 1, $since_id);
				}
			}
		}
		$cv->end;
	});
}

if(-e $file) {
	load_config();
	my ($vc_cv) = verify_cred(get_ae_twitter());
	$vc_cv->recv;
}
elsif($non_interactive) {
	die("Not yet authorised, but currently in non-interactive mode.");
}
else {
	authorise();
}

setup_rest_cv();

my $ua = get_ae_twitter();

my ($cv, $listener) = stream($ua, undef, sub {
	if($preload_tweets) {
		rest_fetch($ua, $rest_cv, $preload_tweets, undef, undef);
	}
	else {
		$rest_cv->send;
	}
});

$cv->recv;
